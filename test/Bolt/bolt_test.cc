#include <gmock/gtest/gtest.h>
#include <util.h>
#include <thread>
#include <fcntl.h>
#include <sys/mman.h>
#include <iostream>
#include "db.h"
#include "testBase.h"

static const int SLEEP_WAIT_TIME = 1;
// open an empty file as db
TEST(dbtest, opentest) {
  std::unique_ptr<DB> ptr(new DB(newFileName()));
  int ret = ptr->Open(Options());
  EXPECT_EQ(ret, 0);
  ptr->DbClose();
}

// //re-open a db
// TEST(dbtest, dbtest_reopendb_Test) {
//   auto name = newFileName();
//   std::unique_ptr<DB> db1(new DB);
//   db1->openDB(name, S_IRWXU);
//   int ret = 0;
//   db1->view([&ret](Tx *txn) {
//     ret = txn->isFreelistCheckOK();
//     return ret;
//   });
//   EXPECT_EQ(ret, 0);
//   db1->closeDB();
//   db1.reset();

//   std::unique_ptr<DB> db2(new DB);
//   db2->openDB(name, S_IRWXU);
//   db2->view([&ret](Tx *txn) {
//     ret = txn->isFreelistCheckOK();
//     return ret;
//   });
//   EXPECT_EQ(ret, 0);
//   db2->closeDB();
// }

// test freeList Function free() can adding accord page to pending_
// and release() can release it to ids_
// and allocate() can get contigious pages
TEST(dbtest, freeListTest) {
  std::unique_ptr<freeList> f(new freeList());
  pgid index = 12;
  uint32_t overflow = 3;
  Page p{ .id = index, .flag = 0, .count = 0, .overflow = overflow };
  f->free(100, &p);
  auto it = f->pending_[100].begin();
  for (uint32_t i = 0; i <= overflow; i++) {
    EXPECT_EQ(index + i, *it++);
  }
  f->release(100);
  auto it_ids = f->ids_.begin();
  for (uint32_t i = 0; i <= overflow; i++) {
    EXPECT_EQ(index + i, *it_ids++);
  }
  pgid pg = f->allocate(4);
  EXPECT_EQ(pg, index);
}

// --gtest_catch_exceptions=0
TEST(dbtest, start_transaction) {
  std::unique_ptr<DB> db(new DB(newFileName()));
  int ret = db->Open(Options());
  EXPECT_EQ(ret, 0);
  std::function<int(TxPtr)> func = [](TxPtr tx)->int {
    LOG(INFO) << "executing transaction!";
    return 0;
  };
  // 只要update成功就会持久化这个transaction分配出来的页和meta，无论里面有多少数据
  ret = db->update(func);
  EXPECT_EQ(ret, 0);
  db->DbClose();
}

TEST(dbtest, update_remove_entry_test) {
  Item bucketname(string("roland_test"));
  std::unique_ptr<DB> db(new DB(newFileName()));
  int ret = db->Open(Options());
  EXPECT_EQ(ret, 0);
  std::function<int(TxPtr)> func = [bucketname](TxPtr tx)->int {
    auto b = tx->createBucket(bucketname);
    EXPECT_NE(b, nullptr);
    Item key(string("foo"));
    EXPECT_EQ(b->put(key, key), 0);
    EXPECT_EQ(b->remove(key), 0);
    return 0;
  };
  ret = db->update(func);
  EXPECT_EQ(ret, 0);
  db->DbClose();
}

TEST(dbtest, update_entry_multi_page_test) {
  Item bucketname(string("roland_test"));
  std::unique_ptr<DB> db(new DB(newFileName()));
  int ret = db->Open(Options());
  EXPECT_EQ(ret, 0);
  std::function<int(TxPtr)> func = [bucketname](TxPtr tx)->int {
    auto b = tx->createBucket(bucketname);
    EXPECT_NE(b, nullptr);
    Item key1(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key1, key1), 0);
    Item key2(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key2, key2), 0);
    Item key3(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key3, key3), 0);
    Item key4(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key4, key4), 0);
    Item key5(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key5, key5), 0);
    Item key6(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key6, key6), 0);
    Item key7(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key7, key7), 0);
    Item key8(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key8, key8), 0);
    Item key9(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key9, key9), 0);
    Item key0(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key0, key0), 0);
    Item key(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key, key), 0);
    Item key11(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key11, key11), 0);
    Item key12(string(
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDE"
        "ADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF"
        "DEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBE"
        "AFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEAD"
        "BEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAFDEADBEAF1"));
    EXPECT_EQ(b->put(key12, key12), 0);
    return 0;
  };
  ret = db->update(func);
  EXPECT_EQ(ret, 0);
  db->DbClose();
}

TEST(dbtest, update_query_entry_test) {
  Item bucketname(string("roland_test"));
  std::unique_ptr<DB> db(new DB(newFileName()));
  int ret = db->Open(Options());
  EXPECT_EQ(ret, 0);
  std::function<int(TxPtr)> func = [&bucketname](TxPtr tx)->int {
    auto b = tx->createBucket(bucketname);
    EXPECT_NE(b, nullptr);
    Item key(string("foo"));
    EXPECT_EQ(b->put(key, key), 0);
    return 0;
  };
  ret = db->update(func);
  std::function<int(TxPtr)> viewFunc = [&bucketname](TxPtr tx)->int {
    auto b = tx->getBucket(bucketname);
    EXPECT_NE(b, nullptr);
    Item key1(string("foo"));
    Item key2(string("foo1"));
    auto item1 = b->get(key1);
    EXPECT_EQ(item1, key1);
    auto item2 = b->get(key2);
    EXPECT_EQ(item2.length_, 0);
    return 0;
  };
  ret = db->view(viewFunc);
  EXPECT_EQ(ret, 0);
  db->DbClose();
}
